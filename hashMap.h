/*header automatically generated by autoHead*/
#pragma once
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
extern int mapErr;
#define MAP_NOSUCH 1
#define MALLOC_FAIL 2
#define BUILD_ENTRY(key, val, ret) { \
	if ((ret = malloc(sizeof(Entry))) != NULL){ \
	ret->key = (void*)key; \
	ret->value = (void*)val; \
	ret->next = NULL; \
	} \
}
typedef struct {
    void* key;
    void* value;
} Entry;
typedef struct {
    Entry* entries;
    size_t (*hashf)(const void*);
    /* used for comparison between keys, if they are equal, it should return 0, if different, it should be != 0*/
    int (*compare)(const void*, const void*);
    /* used to free data storage.*/    
    void (*free)(void* key, void* val);
    size_t length;
    size_t occupied;
} HashMap;
HashMap* createMap(const size_t length, size_t (*hash)(const void*), int(*compare)(const void*, const void*),void (*freefn)(void*, void*));
int growMap(HashMap* map, const size_t inc);
int addPair(HashMap* map, const void* key, const void* val);
int removeKey(HashMap* map, const void* key);
void* getValue(const HashMap* map, const void* key);
size_t hasKey(const HashMap* map, const void* key);
void clearMap(HashMap* map);
void discardMap(HashMap* map);
/* very shitty default hash function that should return on anything.*/
size_t defHash(const void* key);
/* function to hash null terminated strings.*/
size_t strHash(const void* key);
int strcmpWrap(const void* strA, const void* strB);
void defaultFree(void* key, void* value);
/*verbosity indicates what to print.
 * 0 entry print for all entries
 * 1 prints hashmap entry fill rate.
 * 2 also prints hashmap address and entry adress
*/
void debugPrintMap(const HashMap* map, void (*printEntry)(const Entry*), int verbosity);
/* there's not much I can do about printing, since there can be near infinite pairs, uh have this generic function.*/
void addressPrint(const Entry* pair);
